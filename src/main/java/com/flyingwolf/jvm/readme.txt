				JAVA类加载机制
一、类加载器
	1.启动加载器（Bootstrap ClassLoader）
		负责加载%JAVA_HOME%/lib目录下的，或被-Xbootclasspath参数指定路径中的，
		且可以被虚拟机识别的所有类库（例如：rt.jar）；
	2.扩展加载器（ExtClassLoader）
		负责加载%JAVA_HOME%/lib/ext/目录下的，或由java.ext.dirs系统变量知道路径中的所有类库；
	3.程序加载器（AppClassLoader）
		负责加载用户类路径classpath指定路径的所有类。
	4.自定义加载器（User ClassLoader）
	
二、类加载机制
	1.全盘负责：根据类的全限定名称获取二进制流
	2.父类委派：先让父类尝试加载，只有父类无法完成加载时才尝试从自己的类路径中加载
	3.缓存机制：当应用程序需要使用某个类时，加载器先从缓存区查找class，只有在缓存不存在时才会读取class的二进制数据，并转换为class对象放入缓存区。

三、双亲委派模型
	先将加载任务委托给父类加载器，依次递归，最终应该有启动加载器先尝试加载，只有父加载器加载不成功时才会自己去加载。
四、类的生命周期
	1.加载：将class的二进制数据量转换为运行时数据结构放入JVM方法区，在Java堆中生成一个对象作为方法区数据的访问入口。
	2.链接
		1)验证：文件格式验证、元数据验证、字节码验证、符号引用验证
		2)准备：为静态变量分配内存空间，并赋初始默认值
		3)解释：把类中所有符号引用转化为直接引用
	3.初始化：主要对类变量赋初始值，声明类变量的初始值和静态代码块指定的初始值
五、类加载顺序
	1.只有程序首次运行是才会初始化静态代码初始化块、静态成员变量、静态方法
	2.调用new方法时创建类的实例
	3.创建实例时初始化顺序：父类初始化块、父类构造方法、子类初始化块、子类构造方法
	4.销毁顺序：先销毁子类再销毁父类

			class类文件结构
4位魔术——确定这个文件是否为一个能被虚拟机接受的class文件
4位版本号——2位次版本号+2位主版本号
常量池——敞亮吃入口放置了常量池计数器(从1开始)，常量池存储了符号常量、final常量值、基本数据类型的字面值
访问标志——占用2字节，用来表示此文件是类或是接口
http://blog.csdn.net/linzhuowei0775/article/details/49556621


	
			JVM内存模型
方法区：存放类描述信息（类的全限定名，直接超类的全限定名，接口全限定名有序列表，访问修饰符）、类的静态变量、常量、即时编译器编译后的代码，线程共享，生命周期与虚拟机相同,配置参数：-XX:PermSize、-XX:MaxPermSize
堆：存放所有对象实例，线程共享，生命周期与虚拟机相同,配置参数：-Xms、-Xmx、-Xmn
虚拟机栈：存放局部变量表、操作栈、动态链接、方法出口等信息，线程私有，生命周期与线程相同，配置参数：-Xss
程序计数器：使用较小的内存空间，字节码行号指示器

			GC垃圾回收
一、哪些需要回收：
	根据虚拟机栈的局部变量表的引用对象、方法区的类静态属性引用对象、方法区的常量引用对象和本地方法栈中的JNI作为根 查找可回收的对象
二、什么时候回收：
	标记清除/标记压缩算法：从根开始将被引用的对象以递归的方式进行标记，没有被标记的对象作为垃圾进行回收或是进行压缩，
					缺点是在分配了大量对象且只有一小部分存活的情况下耗时太长
	复制清除算法：从根开始将被引用的对象复制到另一空间中，在将复制的对象所能够引用的对象用递归的方式复制回去
			 缺点复制所需的开销较大，有点具有局部性 将较近的对象放在了较近的内存空间中，提升了内存读取速度
	引用计数算法：在每个对象中保存该对象的引用计数，当计数为0时可以进行回收，缺点无法释放循环引用的对象
三、怎样回收：
	分代回收机制：
		--Heap的空间分为新生代和老年代，新生代分为Eden和Survivor两部分，其中Survivor分s0和s1两个空间--
		1.新创建的对象实例会放入新生代的Eden空间中
		2.当第一次GC发生时会将Eden空间中仍然存活的对象放入Survivor其中的一个空间
		3.当Survivor放置对象的这个空间满了之后会将存活的对象放入另一个空间中并清空当前空间
		4.重复几次Survivor放置过程后，将仍然存活的对象放入老年代中
		5.老年代中空间满了以后就会发生full gc
	垃圾回收器：
		serial GC（串行垃圾回收器）：标记-汇总-清理；第一步标记老年代中仍然存活的对象，第二步清除，第三步顺序填满空间，并将空间分为两部分，单线程回收
		Parallel GC（并行垃圾回收器）：相比比于Serial GC，Parallel GC使用了多线程，效率更高
		 Parallel Old GC（老年代并行垃圾回收器）：标记-汇总-压缩
		CMS GC（并发标记扫描垃圾回收器）：会占用更多的内存和CUP
		G1 GC：G1适用于堆内存很大的情况，无需分代,将内存分割为不同的区域，优先清理垃圾较多的内存区域
		
	